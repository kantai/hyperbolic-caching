from ycsb_zipf import AccurateDistributionGenerator

def generate_sequence(N, flip_to = -1):
    current_sequence = [0]
    
    cur_len = 1
    cur_i = 1
    while cur_i < N:
        current_sequence += current_sequence
        cur_len *= 2
        current_sequence[-1] = cur_i
        cur_i += 1

    if flip_to >= 0:
        old_seq = current_sequence
        first = True
        current_sequence = []
        for i in old_seq:
            if i == flip_to:
                if first:
                    first = False
                    current_sequence.append(i)
                else:
                    current_sequence.append(cur_i)
                    cur_i += 1
            else:
                current_sequence.append(i)
    return current_sequence

def generate_freqs(N, flip_to = -1):
    lambdas = [1.0 / 2**i for i in range(1, N)]
    lambdas.append(lambdas[-1])
    if flip_to >= 0:
        seq_size = 2**(N - 1)
        item_freq = 1.0 / seq_size
        lambdas[flip_to] = item_freq
        original_cnt = 2**(N - flip_to - 2)
        lambdas += [item_freq for i in range(original_cnt - 1)]
    return lambdas

def check_freqs(N, f):
    seq = generate_sequence(N, f)
    freqs = generate_freqs(N, f)

    counts = [0 for i in freqs]
    csum = 0
    for i in seq:
        counts[i] += 1
        csum += 1
    freqs_m = [float(c) / csum for c in counts]

    return sum([abs(a - b) for (a, b) in zip(freqs_m, freqs)])

def seq_generator_number_of_counts(N, flip_to):
    """ tells you how many big the universe generated by those parameters will be """
    return ((2 ** (N - flip_to - 2)) + N - 1)

class DetermBinaryGenerator(object):
    def __init__(self, count, theta):
        self.N = count
        
        flip_to = 0
        seq_generator = 1
        cur_universe = seq_generator_number_of_counts(seq_generator, flip_to)
        while cur_universe < count:
            seq_generator += 1
            cur_universe = seq_generator_number_of_counts(seq_generator, flip_to)
        
        if cur_universe != count:
            raise Exception("You gave me an unachievable count. Enjoy the exception.")

        self.sequence = generate_sequence(seq_generator, flip_to)
        self.continuation = 0
        self.lambdas = generate_freqs(seq_generator, flip_to)

    def get_popularity(self, item):
        return self.lambdas[item]

    def get_next(self, rand_float):
        item = self.sequence[self.continuation]
        self.continuation = (self.continuation + 1) % self.N
        return (item, self.get_popularity(item))

class RandBinaryGenerator(AccurateDistributionGenerator):
    def __init__(self, count, theta):
        flip_to = 0
        seq_generator = 1
        cur_universe = seq_generator_number_of_counts(seq_generator, flip_to)
        while cur_universe < count:
            seq_generator += 1
            cur_universe = seq_generator_number_of_counts(seq_generator, flip_to)
        
        if cur_universe != count:
            raise Exception("You gave me an unachievable count. Enjoy the exception.")

        super(RandBinaryGenerator, self).__init__(generate_freqs(seq_generator, flip_to))
